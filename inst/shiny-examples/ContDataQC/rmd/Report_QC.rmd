---
title: "Report, Data Quality Control"
subtitle: "ContDataQC"
author: "`r Sys.getenv('USERNAME')`"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: no
  word_document:
    toc: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(results='asis', echo=FALSE, warning=FALSE)
# needed for trouble shooting
boo_DEBUG <- FALSE
if(boo_DEBUG==TRUE){
  myConfig <- file.path(system.file(package="ContDataQC"), "extdata"
                        , "config.ORIG.R")
  source(myConfig)
}
```

# DATA FILE INFORMATION
```{r data_file_info}
  # Report Info
  myReportDate <- format(Sys.Date(),ContData.env$myFormat.Date)
  cat(paste("**Report Date:** ",myReportDate,"\n\n",sep=""))
  myUser <- Sys.getenv("USERNAME")
  cat(paste("**Generated By:** ",myUser,"\n\n",sep=""))
  
  #filename
  cat("**Filename:** ",strFile,"\n\n",sep="")

  mySiteID <- data.import[1,ContData.env$myName.SiteID]
  
  cat(paste("**SiteID:** ",mySiteID,"\n\n",sep=""))
  
  if(exists("fun.myData.DateRange.Start")==TRUE){
    POR.Requested <- paste(fun.myData.DateRange.Start
                           ," to "
                           ,fun.myData.DateRange.End
                           , sep="")
  } else {
    POR.Requested <- "NA"
  }
  cat(paste("**Period of Record, Requested:** "
            ,POR.Requested,sep=""
            ,collapse="\n\n"))
  
  myNumRecords <- nrow(data.import) 
  # 20170228, mod from records 10 and 11 to half way point
  
  # myTimeDiff <- difftime(data.import[10,ContData.env$myName.DateTime]
  #,data.import[11,ContData.env$myName.DateTime],units="mins")
  #x <- data.import[,ContData.env$myName.DateTime]
  myT <- strptime(data.import[,ContData.env$myName.DateTime]
                  ,format=ContData.env$myFormat.DateTime)
  myTimeDiff.all <- difftime(myT[-1],myT[-length(myT)],units="mins")
  myTimeDiff <- median(as.vector(myTimeDiff.all),na.rm=TRUE)

  cat(paste("\n\n**Period of Record, Actual:**"
            ,min(data.import[,ContData.env$myName.Date])
            ," to "
            ,max(data.import[,ContData.env$myName.Date])
            ,"\n\n"
            ,sep=""))
       
  cat(paste("**Recording Interval:** ",myTimeDiff[1]," minutes\n\n",sep=""))
  
  if(exists("strFile.DataType")==TRUE){
    myDataType <- strFile.DataType
  } else {
    myDataType <- "NA"
  }
  cat(paste("**Data Type:** ",myDataType,"\n\n",sep=""))  # need to do better
  
   myParameters.ALL     <- ContData.env$myNames.DataFields[ContData.env$myNames.DataFields 
                                                           %in% names(data.import)==TRUE] 
   myParameters.Lab.ALL <- ContData.env$myNames.DataFields.Lab[ContData.env$myNames.DataFields 
                                                               %in% names(data.import)==TRUE]
   # Filter out Discrete
   myParameters     <- myParameters.ALL[!grepl(ContData.env$myPrefix.Discrete,myParameters.ALL)]
   myParameters.Lab <- myParameters.Lab.ALL[
                                           !grepl(ContData.env$myPrefix.Discrete
                                                   ,myParameters.Lab.ALL)]
   
   
 #cat("**Parameters:** ",paste(myParameters.Lab,", ",sep=""),"\n\n",sep="")
  # above line not working, preventing pandoc conversion to WORD
  #cat("**Included Parameters:** \n\n")
  cat("**Parameters Included:** ",paste(myParameters.ALL
                                        ,", "
                                        ,sep="")
      ,"\n\n"
      ,sep="")
```

# DATA SUMMARY, OVERALL

```{r data_summary_overall, results='asis',echo=FALSE, warning=FALSE}
#     2.1. Records by Month/Day
#     split so easier to put on paper
#     number of records by month/day (split 1:15 and 16:31)
#     
  # format = markdown/pandoc = seems to be the same.  All rows but no columns in Word.
  # Have to use on table not ftable.  ftable better by itself but doesn't work with knitr::kable.

    # # QC, if days less than count = 15
    #*Error in table.  Only printing half.* (fixed for sites with <15 days)
    # if((max(data.import[,"day"])-min(data.import[,"day"]))<15) {##IF.daycount.START
    #   myTable <- table(data.import[,"month"],data.import[,"day"])
    #   print(knitr::kable(myTable, format="markdown",row.names=TRUE))
    # } else {
    #   #
    #   #myTable.month.day.rec.LTE15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]<=15],data.import[,"day"][data.import[,"day"]<=15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    #     #knitr::kable(myTable.month.day.rec.LTE15, format="pandoc", caption = "Title of the table")
    #   cat("\n\n")  
    #   #   
    #   # myTable.month.day.rec.GT15 <-
    #   myTable <- table(data.import[,"month"][data.import[,"day"]>15],data.import[,"day"][data.import[,"day"]>15])
    #     print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      #   
   # }##IF.daycount.END


      # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
        cat("\n\n")

        
    cat("Number of records by year and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Yr]
                                ,data.import[,ContData.env$myName.Mo]
                                , useNA = "ifany"))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n")

    
  # revert to longer table (20170228)
    cat("Number of records by day and month (with totals).")
    cat("\n")
    myTable <- addmargins(table(data.import[,ContData.env$myName.Day]
                                ,data.import[,ContData.env$myName.Mo]
                                , useNA = "ifany"))
        print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    cat("\n\n") 

#     
#     pandoc.table(myTable.month.day.rec.GT15,style="rmarkdown")
#    
#     
    myTable.month.day.rec <- table(data.import[,ContData.env$myName.Mo]
                                   ,data.import[,ContData.env$myName.Day]
                                   , useNA = "ifany")
#     use apply function to count number of records not equal to the expected value
    cat("\n\n")
    

    #
    myTable.DateTime.N <- aggregate(data.import[,ContData.env$myName.SiteID]  
                                    ~ data.import[,ContData.env$myName.DateTime]
                                    , data=data.import,FUN=length)
    # myTable <- myTable.DateTime.N[myTable.DateTime.N[,ContData.env$myName.SiteID]!=1,]
    # cat(paste0("Date and time records with more than one entry; N=",nrow(myTable),". Duplicate date.time records are shown below."))
    # cat("\n")
    #   print(knitr::kable(myTable, format="markdown", row.names=TRUE))
    # mask error, 20170307
    
    # Missing Dates
    
    myDateRange.Data <- seq(as.Date(min(data.import[,ContData.env$myName.Date]))
                            ,as.Date(max(data.import[,ContData.env$myName.Date]))
                            ,by="day")
    
    if(exists("fun.myData.DateRange.Start")==TRUE){
      myDateRange.Target <- seq(as.Date(fun.myData.DateRange.Start)
                              ,as.Date(fun.myData.DateRange.End)
                              ,by="day")
    } else {
      myDateRange.Target <- myDateRange.Data
    }
    
    myDateRange.Target.Missing <- myDateRange.Target[!myDateRange.Target %in% myDateRange.Data]
    cat(paste0("Below are the dates with missing data between the min (",min(myDateRange.Data)
               ,") and max(",max(myDateRange.Data)," for the provided data. There are "
               ,length(myDateRange.Target.Missing)," records."))
    cat("\n\n")
    print(ifelse(length(myDateRange.Target.Missing)==0,"",myDateRange.Target.Missing))

```


# FLAGS
Each data point is checked by each of the four QC tests below. 

* **Unrealistic values (Gross range):** Entries are flagged fi values are above or below
upper or lower limits.
* **Spikes:** Entries are flagged if adjacent points change by more than 'x' amount.
* **Rate of Change (RoC):** Entries are flagged if the RoC exceeds a given threshold (e.g., >= 3 standard deviations within 25 hours).
* **Flat Line (Flat):** Entries are flagged if a certain number of consecutive measurements are within a certain amount of each other (e.g., > 10 consecutive temperature measurements are within 0.01. degrees C of on another).

Flags are assigned to each data point (a single measured parameter at a unique point in time) first by each of the QC tests below.  Flags are assigned the following categories;

```{r flags_legend}
cat(paste("* **",ContData.env$myFlagVal.Pass,"** = Pass,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Suspect,"** = Suspect,",sep=""))  
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Fail,"** = Fail,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.NoData,"** = No Data or Not Applicable (NA).",sep=""))
```


Overall flags are assigned by examining the results of the four tests below. 

```{r flags_overall}
cat(paste("* **",ContData.env$myFlagVal.Pass,"** = no Fail or Suspect and at least one Pass,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.Suspect,"** = no Fail and at least one Suspect,",sep="")) 
cat("\n") 
cat(paste("* **",ContData.env$myFlagVal.Fail,"** = at least one Fail,",sep=""))
cat("\n")
cat(paste("* **",ContData.env$myFlagVal.NoData,"** = unable to perform QC check because no adjacent value(s) to compare to, either due to missing data or because the measurement was taken at the beginning or end of the deployment period.",sep=""))
```

The thresholds used in the tests are defined in the config file and are listed below.

```{r Thresholds}
kbl_caption <- "Thresholds, Quick Reference"
txt_header <- c("Analyte", "Flag", "Gross", "Spike", "Rate of Change", "Flat Line")
# WaterTemp
nam_WaterTemp <- c("myLab.WaterTemp"                       #1
                   , "myUnits.WaterTemp"                    #2
                   , "myThresh.Gross.Fail.Hi.WaterTemp"     #3
                   , "myThresh.Gross.Fail.Lo.WaterTemp"     #4
                   , "myThresh.Gross.Suspect.Hi.WaterTemp"  #5
                   , "myThresh.Gross.Suspect.Lo.WaterTemp"  #6
                   , "myThresh.Spike.Hi.WaterTemp"          #7
                   , "myThresh.Spike.Lo.WaterTemp"          #8
                   , "myThresh.RoC.SD.number.WaterTemp"     #9
                   , "myThresh.RoC.SD.period.WaterTemp"     #10
                   , "myThresh.Flat.Hi.WaterTemp"           #11
                   , "myThresh.Flat.Lo.WaterTemp"           #12
                   , "myThresh.Flat.Tolerance.WaterTemp"    #13
                   )
val_WaterTemp <- mget(nam_WaterTemp, envir=ContData.env)
txt_WaterTemp_F <- c(val_WaterTemp[1]
                     , "Fail"
                     , paste0("> ",val_WaterTemp[3]," deg ",val_WaterTemp[2]
                              ,"  or < ",val_WaterTemp[4]," deg ",val_WaterTemp[2])
                     , paste0(">= ", val_WaterTemp[7]," deg ",val_WaterTemp[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_WaterTemp[11]
                              ," consecutive measurements within ",val_WaterTemp[13]
                              ," units of one another"))
txt_WaterTemp_S <- c(val_WaterTemp[1]
                     , "Suspect"
                     , paste0("> ",val_WaterTemp[5]," deg ",val_WaterTemp[2]
                              ," or < ",val_WaterTemp[6]," deg ",val_WaterTemp[2])
                     , paste0(">= ", val_WaterTemp[8]," deg ",val_WaterTemp[2]," (+/-)")
                     , paste0(">= ",val_WaterTemp[9]," standard deviations within "
                              ,val_WaterTemp[10]," hours")
                     , paste0("> ",val_WaterTemp[12]
                              ," consecutive measurements within ",val_WaterTemp[13]
                              ," units of one another"))
# AirTemp
nam_AirTemp <- c("myLab.AirTemp"                          #1
                   , "myUnits.AirTemp"                    #2
                   , "myThresh.Gross.Fail.Hi.AirTemp"     #3
                   , "myThresh.Gross.Fail.Lo.AirTemp"     #4
                   , "myThresh.Gross.Suspect.Hi.AirTemp"  #5
                   , "myThresh.Gross.Suspect.Lo.AirTemp"  #6
                   , "myThresh.Spike.Hi.AirTemp"          #7
                   , "myThresh.Spike.Lo.AirTemp"          #8
                   , "myThresh.RoC.SD.number.AirTemp"     #9
                   , "myThresh.RoC.SD.period.AirTemp"     #10
                   , "myThresh.Flat.Hi.AirTemp"           #11
                   , "myThresh.Flat.Lo.AirTemp"           #12
                   , "myThresh.Flat.Tolerance.AirTemp"    #13
                   )
val_AirTemp <- mget(nam_AirTemp, envir=ContData.env)
txt_AirTemp_F <- c(val_AirTemp[1]
                     , "Fail"
                     , paste0("> ",val_AirTemp[3]," deg ",val_AirTemp[2]
                              ,"  or < ",val_AirTemp[4]," deg ",val_AirTemp[2])
                     , paste0(">= ", val_AirTemp[7]," deg ",val_AirTemp[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_AirTemp[11]
                              ," consecutive measurements within ",val_AirTemp[13]
                              ," units of one another"))
txt_AirTemp_S <- c(val_AirTemp[1]
                     , "Suspect"
                     , paste0("> ",val_AirTemp[5]," deg ",val_AirTemp[2]
                              ," or < ",val_AirTemp[6]," deg ",val_AirTemp[2])
                     , paste0(">= ", val_AirTemp[8]," deg ",val_AirTemp[2]," (+/-)")
                     , paste0(">= ",val_AirTemp[9]," standard deviations within "
                              ,val_AirTemp[10]," hours")
                     , paste0("> ",val_AirTemp[12]
                              ," consecutive measurements within ",val_AirTemp[13]
                              ," units of one another"))
# WaterP
nam_WaterP <- c("myLab.WaterP"                          #1
                   , "myUnits.WaterP"                    #2
                   , "myThresh.Gross.Fail.Hi.WaterP"     #3
                   , "myThresh.Gross.Fail.Lo.WaterP"     #4
                   , "myThresh.Gross.Suspect.Hi.WaterP"  #5
                   , "myThresh.Gross.Suspect.Lo.WaterP"  #6
                   , "myThresh.Spike.Hi.WaterP"          #7
                   , "myThresh.Spike.Lo.WaterP"          #8
                   , "myThresh.RoC.SD.number.WaterP"     #9
                   , "myThresh.RoC.SD.period.WaterP"     #10
                   , "myThresh.Flat.Hi.WaterP"           #11
                   , "myThresh.Flat.Lo.WaterP"           #12
                   , "myThresh.Flat.Tolerance.WaterP"    #13
                   )
val_WaterP <- mget(nam_WaterP, envir=ContData.env)
txt_WaterP_F <- c(val_WaterP[1]
                     , "Fail"
                     , paste0("> ",val_WaterP[3]," ",val_WaterP[2]
                              ,"  or < ",val_WaterP[4]," ",val_WaterP[2])
                     , paste0(">= ", val_WaterP[7]," ",val_WaterP[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_WaterP[11]
                              ," consecutive measurements within ",val_WaterP[13]
                              ," units of one another"))
txt_WaterP_S <- c(val_WaterP[1]
                     , "Suspect"
                     , paste0("> ",val_WaterP[5]," ",val_WaterP[2]
                              ," or < ",val_WaterP[6]," ",val_WaterP[2])
                     , paste0(">= ", val_WaterP[8]," ",val_WaterP[2]," (+/-)")
                     , paste0(">= ",val_WaterP[9]," standard deviations within "
                              ,val_WaterP[10]," hours")
                     , paste0("> ",val_WaterP[12]
                              ," consecutive measurements within ",val_WaterP[13]
                              ," units of one another"))
# AirBP
nam_AirBP <- c("myLab.AirBP"                          #1
                   , "myUnits.AirBP"                    #2
                   , "myThresh.Gross.Fail.Hi.AirBP"     #3
                   , "myThresh.Gross.Fail.Lo.AirBP"     #4
                   , "myThresh.Gross.Suspect.Hi.AirBP"  #5
                   , "myThresh.Gross.Suspect.Lo.AirBP"  #6
                   , "myThresh.Spike.Hi.AirBP"          #7
                   , "myThresh.Spike.Lo.AirBP"          #8
                   , "myThresh.RoC.SD.number.AirBP"     #9
                   , "myThresh.RoC.SD.period.AirBP"     #10
                   , "myThresh.Flat.Hi.AirBP"           #11
                   , "myThresh.Flat.Lo.AirBP"           #12
                   , "myThresh.Flat.Tolerance.AirBP"    #13
                   )
val_AirBP <- mget(nam_AirBP, envir=ContData.env)
txt_AirBP_F <- c(val_AirBP[1]
                     , "Fail"
                     , paste0("> ",val_AirBP[3]," ",val_AirBP[2]
                              ,"  or < ",val_AirBP[4]," ",val_AirBP[2])
                     , paste0(">= ", val_AirBP[7]," ",val_AirBP[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_AirBP[11]
                              ," consecutive measurements within ",val_AirBP[13]
                              ," units of one another"))
txt_AirBP_S <- c(val_AirBP[1]
                     , "Suspect"
                     , paste0("> ",val_AirBP[5]," ",val_AirBP[2]
                              ," or < ",val_AirBP[6]," ",val_AirBP[2])
                     , paste0(">= ", val_AirBP[8]," ",val_AirBP[2]," (+/-)")
                     , paste0(">= ",val_AirBP[9]," standard deviations within "
                              ,val_AirBP[10]," hours")
                     , paste0("> ",val_AirBP[12]
                              ," consecutive measurements within ",val_AirBP[13]
                              ," units of one another"))
# SensorDepth
nam_SensorDepth <- c("myLab.SensorDepth"                          #1
                   , "myUnits.SensorDepth"                    #2
                   , "myThresh.Gross.Fail.Hi.SensorDepth"     #3
                   , "myThresh.Gross.Fail.Lo.SensorDepth"     #4
                   , "myThresh.Gross.Suspect.Hi.SensorDepth"  #5
                   , "myThresh.Gross.Suspect.Lo.SensorDepth"  #6
                   , "myThresh.Spike.Hi.SensorDepth"          #7
                   , "myThresh.Spike.Lo.SensorDepth"          #8
                   , "myThresh.RoC.SD.number.SensorDepth"     #9
                   , "myThresh.RoC.SD.period.SensorDepth"     #10
                   , "myThresh.Flat.Hi.SensorDepth"           #11
                   , "myThresh.Flat.Lo.SensorDepth"           #12
                   , "myThresh.Flat.Tolerance.SensorDepth"    #13
                   )
val_SensorDepth <- mget(nam_SensorDepth, envir=ContData.env)
txt_SensorDepth_F <- c(val_SensorDepth[1]
                     , "Fail"
                     , paste0("> ",val_SensorDepth[3]," ",val_SensorDepth[2]
                              ,"  or < ",val_SensorDepth[4]," ",val_SensorDepth[2])
                     , paste0(">= ", val_SensorDepth[7]," ",val_SensorDepth[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_SensorDepth[11]
                              ," consecutive measurements within ",val_SensorDepth[13]
                              ," units of one another"))
txt_SensorDepth_S <- c(val_SensorDepth[1]
                     , "Suspect"
                     , paste0("> ",val_SensorDepth[5]," ",val_SensorDepth[2]
                              ," or < ",val_SensorDepth[6]," ",val_SensorDepth[2])
                     , paste0(">= ", val_SensorDepth[8]," ",val_SensorDepth[2]," (+/-)")
                     , paste0(">= ",val_SensorDepth[9]," standard deviations within "
                              ,val_SensorDepth[10]," hours")
                     , paste0("> ",val_SensorDepth[12]
                              ," consecutive measurements within ",val_SensorDepth[13]
                              ," units of one another"))
# Discharge
nam_Discharge <- c("myLab.Discharge"                          #1
                   , "myUnits.Discharge"                    #2
                   , "myThresh.Gross.Fail.Hi.Discharge"     #3
                   , "myThresh.Gross.Fail.Lo.Discharge"     #4
                   , "myThresh.Gross.Suspect.Hi.Discharge"  #5
                   , "myThresh.Gross.Suspect.Lo.Discharge"  #6
                   , "myThresh.Spike.Hi.Discharge"          #7
                   , "myThresh.Spike.Lo.Discharge"          #8
                   , "myThresh.RoC.SD.number.Discharge"     #9
                   , "myThresh.RoC.SD.period.Discharge"     #10
                   , "myThresh.Flat.Hi.Discharge"           #11
                   , "myThresh.Flat.Lo.Discharge"           #12
                   , "myThresh.Flat.Tolerance.Discharge"    #13
                   )
val_Discharge <- mget(nam_Discharge, envir=ContData.env)
txt_Discharge_F <- c(val_Discharge[1]
                     , "Fail"
                     , paste0("> ",val_Discharge[3]," ",val_Discharge[2]
                              ,"  or < ",val_Discharge[4]," ",val_Discharge[2])
                     , paste0(">= ", val_Discharge[7]," ",val_Discharge[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_Discharge[11]
                              ," consecutive measurements within ",val_Discharge[13]
                              ," units of one another"))
txt_Discharge_S <- c(val_Discharge[1]
                     , "Suspect"
                     , paste0("> ",val_Discharge[5]," ",val_Discharge[2]
                              ," or < ",val_Discharge[6]," ",val_Discharge[2])
                     , paste0(">= ", val_Discharge[8]," ",val_Discharge[2]," (+/-)")
                     , paste0(">= ",val_Discharge[9]," standard deviations within "
                              ,val_Discharge[10]," hours")
                     , paste0("> ",val_Discharge[12]
                              ," consecutive measurements within ",val_Discharge[13]
                              ," units of one another"))
# Cond
nam_Cond <- c("myLab.Cond"                          #1
                   , "myUnits.Cond"                    #2
                   , "myThresh.Gross.Fail.Hi.Cond"     #3
                   , "myThresh.Gross.Fail.Lo.Cond"     #4
                   , "myThresh.Gross.Suspect.Hi.Cond"  #5
                   , "myThresh.Gross.Suspect.Lo.Cond"  #6
                   , "myThresh.Spike.Hi.Cond"          #7
                   , "myThresh.Spike.Lo.Cond"          #8
                   , "myThresh.RoC.SD.number.Cond"     #9
                   , "myThresh.RoC.SD.period.Cond"     #10
                   , "myThresh.Flat.Hi.Cond"           #11
                   , "myThresh.Flat.Lo.Cond"           #12
                   , "myThresh.Flat.Tolerance.Cond"    #13
                   )
val_Cond <- mget(nam_Cond, envir=ContData.env)
txt_Cond_F <- c(val_Cond[1]
                     , "Fail"
                     , paste0("> ",val_Cond[3]," ",val_Cond[2]
                              ,"  or < ",val_Cond[4]," ",val_Cond[2])
                     , paste0(">= ", val_Cond[7]," ",val_Cond[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_Cond[11]
                              ," consecutive measurements within ",val_Cond[13]
                              ," units of one another"))
txt_Cond_S <- c(val_Cond[1]
                     , "Suspect"
                     , paste0("> ",val_Cond[5]," ",val_Cond[2]
                              ," or < ",val_Cond[6]," ",val_Cond[2])
                     , paste0(">= ", val_Cond[8]," ",val_Cond[2]," (+/-)")
                     , paste0(">= ",val_Cond[9]," standard deviations within "
                              ,val_Cond[10]," hours")
                     , paste0("> ",val_Cond[12]
                              ," consecutive measurements within ",val_Cond[13]
                              ," units of one another"))
# DO, mg/L
nam_DO <- c("myLab.DO"                          #1
                   , "myUnits.DO"                    #2
                   , "myThresh.Gross.Fail.Hi.DO"     #3
                   , "myThresh.Gross.Fail.Lo.DO"     #4
                   , "myThresh.Gross.Suspect.Hi.DO"  #5
                   , "myThresh.Gross.Suspect.Lo.DO"  #6
                   , "myThresh.Spike.Hi.DO"          #7
                   , "myThresh.Spike.Lo.DO"          #8
                   , "myThresh.RoC.SD.number.DO"     #9
                   , "myThresh.RoC.SD.period.DO"     #10
                   , "myThresh.Flat.Hi.DO"           #11
                   , "myThresh.Flat.Lo.DO"           #12
                   , "myThresh.Flat.Tolerance.DO"    #13
                   )
val_DO <- mget(nam_DO, envir=ContData.env)
txt_DO_F <- c(val_DO[1]
                     , "Fail"
                     , paste0("> ",val_DO[3]," ",val_DO[2]
                              ,"  or < ",val_DO[4]," ",val_DO[2])
                     , paste0(">= ", val_DO[7]," ",val_DO[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_DO[11]
                              ," consecutive measurements within ",val_DO[13]
                              ," units of one another"))
txt_DO_S <- c(val_DO[1]
                     , "Suspect"
                     , paste0("> ",val_DO[5]," ",val_DO[2]
                              ," or < ",val_DO[6]," ",val_DO[2])
                     , paste0(">= ", val_DO[8]," ",val_DO[2]," (+/-)")
                     , paste0(">= ",val_DO[9]," standard deviations within "
                              ,val_DO[10]," hours")
                     , paste0("> ",val_DO[12]
                              ," consecutive measurements within ",val_DO[13]
                              ," units of one another"))
# DO, adj
nam_DO.adj <- c("myLab.DO.adj"                          #1
                   , "myUnits.DO.adj"                    #2
                   , "myThresh.Gross.Fail.Hi.DO.adj"     #3
                   , "myThresh.Gross.Fail.Lo.DO.adj"     #4
                   , "myThresh.Gross.Suspect.Hi.DO.adj"  #5
                   , "myThresh.Gross.Suspect.Lo.DO.adj"  #6
                   , "myThresh.Spike.Hi.DO.adj"          #7
                   , "myThresh.Spike.Lo.DO.adj"          #8
                   , "myThresh.RoC.SD.number.DO.adj"     #9
                   , "myThresh.RoC.SD.period.DO.adj"     #10
                   , "myThresh.Flat.Hi.DO.adj"           #11
                   , "myThresh.Flat.Lo.DO.adj"           #12
                   , "myThresh.Flat.Tolerance.DO.adj"    #13
                   )
val_DO.adj <- mget(nam_DO.adj, envir=ContData.env)
txt_DO_F.adj <- c(val_DO.adj[1]
                     , "Fail"
                     , paste0("> ",val_DO.adj[3]," ",val_DO.adj[2]
                              ,"  or < ",val_DO.adj[4]," ",val_DO.adj[2])
                     , paste0(">= ", val_DO.adj[7]," ",val_DO.adj[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_DO.adj[11]
                              ," consecutive measurements within ",val_DO.adj[13]
                              ," units of one another"))
txt_DO_S.adj <- c(val_DO.adj[1]
                     , "Suspect"
                     , paste0("> ",val_DO.adj[5]," ",val_DO.adj[2]
                              ," or < ",val_DO.adj[6]," ",val_DO.adj[2])
                     , paste0(">= ", val_DO.adj[8]," ",val_DO.adj[2]," (+/-)")
                     , paste0(">= ",val_DO.adj[9]," standard deviations within "
                              ,val_DO.adj[10]," hours")
                     , paste0("> ",val_DO.adj[12]
                              ," consecutive measurements within ",val_DO.adj[13]
                              ," units of one another"))

# DO, pct sat
nam_DO.pctsat <- c("myLab.DO.pctsat"                          #1
                   , "myUnits.DO.pctsat"                    #2
                   , "myThresh.Gross.Fail.Hi.DO.pctsat"     #3
                   , "myThresh.Gross.Fail.Lo.DO.pctsat"     #4
                   , "myThresh.Gross.Suspect.Hi.DO.pctsat"  #5
                   , "myThresh.Gross.Suspect.Lo.DO.pctsat"  #6
                   , "myThresh.Spike.Hi.DO.pctsat"          #7
                   , "myThresh.Spike.Lo.DO.pctsat"          #8
                   , "myThresh.RoC.SD.number.DO.pctsat"     #9
                   , "myThresh.RoC.SD.period.DO.pctsat"     #10
                   , "myThresh.Flat.Hi.DO.pctsat"           #11
                   , "myThresh.Flat.Lo.DO.pctsat"           #12
                   , "myThresh.Flat.Tolerance.DO.pctsat"    #13
                   )
val_DO.pctsat <- mget(nam_DO.pctsat, envir=ContData.env)
txt_DO_F.pctsat <- c(val_DO.pctsat[1]
                     , "Fail"
                     , paste0("> ",val_DO.pctsat[3]," ",val_DO.pctsat[2]
                              ,"  or < ",val_DO.pctsat[4]," ",val_DO.pctsat[2])
                     , paste0(">= ", val_DO.pctsat[7]," ",val_DO.pctsat[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_DO.pctsat[11]
                              ," consecutive measurements within ",val_DO.pctsat[13]
                              ," units of one another"))
txt_DO_S.pctsat <- c(val_DO.pctsat[1]
                     , "Suspect"
                     , paste0("> ",val_DO.pctsat[5]," ",val_DO.pctsat[2]
                              ," or < ",val_DO.pctsat[6]," ",val_DO.pctsat[2])
                     , paste0(">= ", val_DO.pctsat[8]," ",val_DO[2]," (+/-)")
                     , paste0(">= ",val_DO.pctsat[9]," standard deviations within "
                              ,val_DO.pctsat[10]," hours")
                     , paste0("> ",val_DO.pctsat[12]
                              ," consecutive measurements within ",val_DO.pctsat[13]
                              ," units of one another"))
# pH
nam_pH <- c("myLab.pH"                          #1
                   , "myUnits.pH"                    #2
                   , "myThresh.Gross.Fail.Hi.pH"     #3
                   , "myThresh.Gross.Fail.Lo.pH"     #4
                   , "myThresh.Gross.Suspect.Hi.pH"  #5
                   , "myThresh.Gross.Suspect.Lo.pH"  #6
                   , "myThresh.Spike.Hi.pH"          #7
                   , "myThresh.Spike.Lo.pH"          #8
                   , "myThresh.RoC.SD.number.pH"     #9
                   , "myThresh.RoC.SD.period.pH"     #10
                   , "myThresh.Flat.Hi.pH"           #11
                   , "myThresh.Flat.Lo.pH"           #12
                   , "myThresh.Flat.Tolerance.pH"    #13
                   )
val_pH <- mget(nam_pH, envir=ContData.env)
txt_pH_F <- c(val_pH[1]
                     , "Fail"
                     , paste0("> ",val_pH[3]," ",val_pH[2]
                              ,"  or < ",val_pH[4]," ",val_pH[2])
                     , paste0(">= ", val_pH[7]," ",val_pH[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_pH[11]
                              ," consecutive measurements within ",val_pH[13]
                              ," units of one another"))
txt_pH_S <- c(val_pH[1]
                     , "Suspect"
                     , paste0("> ",val_pH[5]," ",val_pH[2]
                              ," or < ",val_pH[6]," ",val_pH[2])
                     , paste0(">= ", val_pH[8]," ",val_pH[2]," (+/-)")
                     , paste0(">= ",val_pH[9]," standard deviations within "
                              ,val_pH[10]," hours")
                     , paste0("> ",val_pH[12]
                              ," consecutive measurements within ",val_pH[13]
                              ," units of one another"))
# Turbidity
nam_Turbidity <- c("myLab.Turbidity"                          #1
                   , "myUnits.Turbidity"                    #2
                   , "myThresh.Gross.Fail.Hi.Turbidity"     #3
                   , "myThresh.Gross.Fail.Lo.Turbidity"     #4
                   , "myThresh.Gross.Suspect.Hi.Turbidity"  #5
                   , "myThresh.Gross.Suspect.Lo.Turbidity"  #6
                   , "myThresh.Spike.Hi.Turbidity"          #7
                   , "myThresh.Spike.Lo.Turbidity"          #8
                   , "myThresh.RoC.SD.number.Turbidity"     #9
                   , "myThresh.RoC.SD.period.Turbidity"     #10
                   , "myThresh.Flat.Hi.Turbidity"           #11
                   , "myThresh.Flat.Lo.Turbidity"           #12
                   , "myThresh.Flat.Tolerance.Turbidity"    #13
                   )
val_Turbidity <- mget(nam_Turbidity, envir=ContData.env)
txt_Turbidity_F <- c(val_Turbidity[1]
                     , "Fail"
                     , paste0("> ",val_Turbidity[3]," ",val_Turbidity[2]
                              ,"  or < ",val_Turbidity[4]," ",val_Turbidity[2])
                     , paste0(">= ", val_Turbidity[7]," ",val_Turbidity[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_Turbidity[11]
                              ," consecutive measurements within ",val_Turbidity[13]
                              ," units of one another"))
txt_Turbidity_S <- c(val_Turbidity[1]
                     , "Suspect"
                     , paste0("> ",val_Turbidity[5]," ",val_Turbidity[2]
                              ," or < ",val_Turbidity[6]," ",val_Turbidity[2])
                     , paste0(">= ", val_Turbidity[8]," ",val_Turbidity[2]," (+/-)")
                     , paste0(">= ",val_Turbidity[9]," standard deviations within "
                              ,val_Turbidity[10]," hours")
                     , paste0("> ",val_Turbidity[12]
                              ," consecutive measurements within ",val_Turbidity[13]
                              ," units of one another"))
# Chlorophylla
nam_Chlorophylla <- c("myLab.Chlorophylla"                          #1
                   , "myUnits.Chlorophylla"                    #2
                   , "myThresh.Gross.Fail.Hi.Chlorophylla"     #3
                   , "myThresh.Gross.Fail.Lo.Chlorophylla"     #4
                   , "myThresh.Gross.Suspect.Hi.Chlorophylla"  #5
                   , "myThresh.Gross.Suspect.Lo.Chlorophylla"  #6
                   , "myThresh.Spike.Hi.Chlorophylla"          #7
                   , "myThresh.Spike.Lo.Chlorophylla"          #8
                   , "myThresh.RoC.SD.number.Chlorophylla"     #9
                   , "myThresh.RoC.SD.period.Chlorophylla"     #10
                   , "myThresh.Flat.Hi.Chlorophylla"           #11
                   , "myThresh.Flat.Lo.Chlorophylla"           #12
                   , "myThresh.Flat.Tolerance.Chlorophylla"    #13
                   )
val_Chlorophylla <- mget(nam_Chlorophylla, envir=ContData.env)
txt_Chlorophylla_F <- c(val_Chlorophylla[1]
                     , "Fail"
                     , paste0("> ",val_Chlorophylla[3]," ",val_Chlorophylla[2]
                              ,"  or < ",val_Chlorophylla[4]," ",val_Chlorophylla[2])
                     , paste0(">= ", val_Chlorophylla[7]," ",val_Chlorophylla[2]," (+/-)")
                     , "NA"
                     , paste0("> ",val_Chlorophylla[11]
                              ," consecutive measurements within ",val_Chlorophylla[13]
                              ," units of one another"))
txt_Chlorophylla_S <- c(val_Chlorophylla[1]
                     , "Suspect"
                     , paste0("> ",val_Chlorophylla[5]," ",val_Chlorophylla[2]
                              ," or < ",val_Chlorophylla[6]," ",val_Chlorophylla[2])
                     , paste0(">= ", val_Chlorophylla[8]," ",val_Chlorophylla[2]," (+/-)")
                     , paste0(">= ",val_Chlorophylla[9]," standard deviations within "
                              ,val_Chlorophylla[10]," hours")
                     , paste0("> ",val_Chlorophylla[12]
                              ," consecutive measurements within ",val_Chlorophylla[13]
                              ," units of one another"))
# WaterLevel
nam_WaterLevel <- c("myLab.WaterLevel"                          #1
                   , "myUnits.WaterLevel"                    #2
                   , "myThresh.Gross.Fail.Hi.WaterLevel"     #3
                   , "myThresh.Gross.Fail.Lo.WaterLevel"     #4
                   , "myThresh.Gross.Suspect.Hi.WaterLevel"  #5
                   , "myThresh.Gross.Suspect.Lo.WaterLevel"  #6
                   #, "myThresh.Spike.Hi.WaterLevel"          #7 -removed
                   #, "myThresh.Spike.Lo.WaterLevel"          #8 - removed
                   , "myThresh.RoC.SD.number.WaterLevel"     #9 - 7
                   , "myThresh.RoC.SD.period.WaterLevel"     #10 - 8
                   , "myThresh.Flat.Hi.WaterLevel"           #11 - 9
                   , "myThresh.Flat.Lo.WaterLevel"           #12 - 10
                   , "myThresh.Flat.Tolerance.WaterLevel"    #13 - 11
                   )
val_WaterLevel <- mget(nam_WaterLevel, envir=ContData.env)
txt_WaterLevel_F <- c(val_WaterLevel[1]
                     , "Fail"
                     , paste0("> ",val_WaterLevel[3]," ",val_WaterLevel[2]
                              ,"  or < ",val_WaterLevel[4]," ",val_WaterLevel[2])
                     , "NA"
                     , "NA"
                     , paste0("> ",val_WaterLevel[9]
                              ," consecutive measurements within ",val_WaterLevel[11]
                              ," units of one another"))
txt_WaterLevel_S <- c(val_WaterLevel[1]
                     , "Suspect"
                     , paste0("> ",val_WaterLevel[5]," ",val_WaterLevel[2]
                              ," or < ",val_WaterLevel[6]," ",val_WaterLevel[2])
                     , "NA"
                     , paste0(">= ",val_WaterLevel[7]," standard deviations within "
                              ,val_WaterLevel[8]," hours")
                     , paste0("> ",val_WaterLevel[10]
                              ," consecutive measurements within ",val_WaterLevel[11]
                              ," units of one another"))

# Salinity
nam_Salinity <- c("myLab.Salinity"                          #1
                   , "myUnits.Salinity"                    #2
                   , "myThresh.Gross.Fail.Hi.Salinity"     #3
                   , "myThresh.Gross.Fail.Lo.Salinity"     #4
                   , "myThresh.Gross.Suspect.Hi.Salinity"  #5
                   , "myThresh.Gross.Suspect.Lo.Salinity"  #6
                   , "myThresh.Spike.Hi.Salinity"          #7
                   , "myThresh.Spike.Lo.Salinity"          #8
                   , "myThresh.RoC.SD.number.Salinity"     #9
                   , "myThresh.RoC.SD.period.Salinity"     #10
                   , "myThresh.Flat.Hi.Salinity"           #11
                   , "myThresh.Flat.Lo.Salinity"           #12
                   , "myThresh.Flat.Tolerance.Salinity"    #13
                   )
val_Salinity <- mget(nam_Salinity, envir=ContData.env)
txt_Salinity_F <- c(val_Salinity[1]
                     , "Fail"
                     , paste0("> ",val_Salinity[3]," ",val_Salinity[2]
                              ,"  or < ",val_Salinity[4]," ",val_Salinity[2])
                     , "NA"
                     , "NA"
                     , paste0("> ",val_Salinity[11]
                              ," consecutive measurements within ",val_Salinity[13]
                              ," units of one another"))
txt_Salinity_S <- c(val_Salinity[1]
                     , "Suspect"
                     , paste0("> ",val_Salinity[5]," ",val_Salinity[2]
                              ," or < ",val_Salinity[6]," ",val_Salinity[2])
                     , "NA"
                     , paste0(">= ",val_Salinity[9]," standard deviations within "
                              ,val_Salinity[10]," hours")
                     , paste0("> ",val_Salinity[12]
                              ," consecutive measurements within ",val_Salinity[13]
                              ," units of one another"))

# Create Table
## Display only those parameters used in current dataset (data.import)
# QC
boo.QC <- FALSE
if(boo.QC==TRUE){##IF.boo.QC.START
  # Ensure have ContDat.env loaded
  myConfig <- file.path(system.file(package="ContDataQC"), "extdata", "config.ORIG.R")
  source(myConfig)
  # load dat.import
  fn.import <- file.path(getwd(), "Data1_RAW", "test2_AW_20130426_20130725.csv")
  data.import <- read.csv(fn.import)
}##IF.boo.QC.END
#
# Check for Presence of each Analyte in data
# if not present convert to NULL
# if NULL then won't be included in result data.frame
if(!(ContData.env$myName.WaterTemp %in% names(data.import))){
  txt_WaterTemp_F <- NULL
  txt_WaterTemp_S <- NULL
}
#                    
if(!(ContData.env$myName.AirTemp %in% names(data.import))){
  txt_AirTemp_F <- NULL
  txt_AirTemp_S <- NULL
} 
#
if(!(ContData.env$myName.WaterP %in% names(data.import))){
  txt_WaterP_F <- NULL
  txt_WaterP_S <- NULL
}
#
if(!(ContData.env$myName.AirBP %in% names(data.import))){
  txt_AirBP_F <- NULL
  txt_AirBP_S <- NULL
} 
#
if(!(ContData.env$myName.SensorDepth %in% names(data.import))){
  txt_SensorDepth_F <- NULL
  txt_SensorDepth_S <- NULL
} 
#
if(!(ContData.env$myName.Discharge %in% names(data.import))){
  txt_Discharge_F <- NULL
  txt_Discharge_S <- NULL
} 
#
if(!(ContData.env$myName.Cond %in% names(data.import))){
  txt_Cond_F <- NULL
  txt_Cond_S <- NULL
} 
#
if(!(ContData.env$myName.DO %in% names(data.import))){
  txt_DO_F <- NULL
  txt_DO_S <- NULL
}
#
if(!(ContData.env$myName.DO.adj %in% names(data.import))){
  txt_DO_F.adj <- NULL
  txt_DO_S.adj <- NULL
}
#
if(!(ContData.env$myName.DO.pctsat %in% names(data.import))){
  txt_DO_F.pctsat <- NULL
  txt_DO_S.pctsat <- NULL
}
#
if(!(ContData.env$myName.pH %in% names(data.import))){
  txt_pH_F <- NULL
  txt_pH_S <- NULL
}
#
if(!(ContData.env$myName.Turbidity %in% names(data.import))){
  txt_Turbidity_F <- NULL
  txt_Turbidity_S <- NULL
} 
#
if(!(ContData.env$myName.Chlorophylla %in% names(data.import))){
  txt_Chlorophylla_F <- NULL
  txt_Chlorophylla_S <- NULL
} 
#
if(!(ContData.env$myName.WaterLevel %in% names(data.import))){
  txt_WaterLevel_F <- NULL
  txt_WaterLevel_S <- NULL
} 
#
if(!(ContData.env$myName.Salinity %in% names(data.import))){
  txt_Salinity_F <- NULL
  txt_Salinity_S <- NULL
}
# Table
df_Env <- data.frame(rbind(txt_WaterTemp_F, txt_WaterTemp_S
                           ,txt_AirTemp_F, txt_AirTemp_S
                           , txt_WaterP_F, txt_WaterP_S
                           , txt_AirBP_F, txt_AirBP_S
                           , txt_SensorDepth_F, txt_SensorDepth_S
                           , txt_Discharge_F, txt_Discharge_S
                           , txt_Cond_F, txt_Cond_S
                           , txt_DO_F, txt_DO_S
                           , txt_DO_F.adj, txt_DO_S.adj
                           , txt_DO_F.pctsat, txt_DO_S.pctsat
                           , txt_pH_F, txt_pH_S
                           , txt_Turbidity_F, txt_Turbidity_S
                           , txt_Chlorophylla_F, txt_Chlorophylla_S
                           , txt_WaterLevel_F, txt_WaterLevel_S
                           , txt_Salinity_F, txt_Salinity_S
                           )
                     , row.names = NULL)
names(df_Env) <- txt_header
knitr::kable(df_Env, caption = kbl_caption)
```

Overall flags by parameter

```{r flags_parameters}
#
     for (j in 1:length(myParameters)) {##FOR.j.START
#       #
       #j.num <- match(j,myParameters)
 #   cat(paste(myParameters.Lab[j.num],"/n/n",sep=""))
       
       # ISSUE WITH knitr::kable INSIDE OF LOOPS
       
    cat(paste("## ",myParameters[j],"\n\n",sep=""))

       colnum <- match(paste("Flag",myParameters[j],sep="."),names(data.import))
       
       #print(myTable.Flags.Overall <- ftable(data.import[,colnum]))
       myTable <- addmargins(table(data.import[,colnum]
                                   , useNA = "ifany")
                             ,1)
       print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
       # future mod, 1,3,4,9 to Pass, Suspect, Fail, NA
       # exclude=NA to get all
       # future mod, 2nd line in table to include Percent of row total
       # future mod, sort levels
       
       cat("\n\n")
       
#       #
     }##FOR.j.END
```

# QC TESTS, BY PARAMETER

```{r qc_tests_parameters}
 # 3. Data Info, by Parameter
    # Individual Data Type Report
    # QC
    #i <- myParameters[1]

     for (i in myParameters) {##FOR.i.START
#       #
       i.num <- match(i,myParameters)
       myTitle.Sub <- myParameters.Lab[i.num]
       
       
      cat("## QC TESTS, ",i,"\n\n",sep="")
       
       #cat(paste("**QC TESTS,",myTitle.Sub,sep=""))
       
       # 3.1. Flags, overall
       cat(myTitle.Sub <- "### Flags")
             cat("\n\n")
      cat("#### Flag summary, overall number of records.")
      cat("\n\n")
       myTable <- addmargins(table(data.import[,paste("Flag",i,sep=".")]
                                   , useNA = "ifany")
                             ,1)
       print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
      
      cat("\n\n")
       
      #
      # 3.1. Number of Records (revised 20170228)
       # Convert time interval (minutes) to number per day
      records.expected <- round(24*60/as.numeric(myTimeDiff[1]),1)
      cat(paste("Estimated number of records per day is ",records.expected,".",sep=""))
      cat("\n\n")
      #
      cat("Number of records by year and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Yr]
                                  ,data.import[,ContData.env$myName.Mo]
                                  , useNA = "ifany"))
      print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      cat("\n\n")
      #
      cat("Number of records by day and month (with totals)")
      cat("\n")
      myTable <- addmargins(table(data.import[,ContData.env$myName.Day]
                                  ,data.import[,ContData.env$myName.Mo]
                                  , useNA = "ifany"))
      print(knitr::kable(myTable, format="markdown", row.names=TRUE))
      cat("\n\n") 
      #
      # identify days/months where not the expected number of records
      # (expect first and last day)
  #    print("days where not the expected number of records")
      #
      # 3.2. Flags by QC Test
      
      cat("\n\n")
      
      cat("#### Flags by QC Test")
      
      cat("\n\n")
      
      cat("##### Flags, Gross\n\n")
      
      myTable <- addmargins(table(data.import[, paste(ContData.env$myName.Flag
                                                      ,"Gross"
                                                      ,i
                                                      ,sep=".")]
                                  , useNA = "ifany")
                            ,1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, Spike\n\n")
      
      myTable <- addmargins(table(data.import[, paste(ContData.env$myName.Flag
                                                     ,"Spike"
                                                     ,i
                                                     ,sep=".")]
                                  , useNA = "ifany")
                            ,1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, RoC\n\n")
      
      myTable <- addmargins(table(data.import[, paste(ContData.env$myName.Flag
                                                      ,"RoC"
                                                      ,i
                                                      ,sep=".")]
                                  , useNA = "ifany")
                            ,1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("##### Flags, Flat\n\n")
      
      myTable <- addmargins(table(data.import[, paste(ContData.env$myName.Flag
                                                      ,"Flat"
                                                      ,i
                                                      ,sep=".")]
                                  , useNA = "ifany")
                            ,1)
      print(knitr::kable(t(as.matrix(myTable)), format = "markdown"))
        cat("\n\n")
      cat("QC Test Flag fields are saved in the data file so the user can identify data points that have been flagged as suspect or fail.")
     
      #
      #myFlagTests <- c("Gross","Spike","RoC","Flat")
      #(myTable.Flags.Flat <- ftable(data.import[,paste("Flag",myFlagTests,i,sep=".")]))
      #
      
      
      cat(paste("\n\n Test results marked as ",ContData.env$myFlagVal.NoData," (No/Missing Data) if unable to calculate the end point needed for the test.  For example, the first record does not have a previous record for comparison for the Gross QC Test.  QC Test flags are saved in the data file.",sep=""))
      
      #
      # 3.3. Plot
      data.plot <- data.import
      #
      plot_format <- "ggplot" # "base" or "ggplot"
      #
      if(plot_format=="base"){##IF~plot_format~START
        # plot, base ####
         # cheat on Date/Time axis
        n.Total <- length(data.plot[,ContData.env$myName.Date])
        pct <- c(20,40,60,80,100)*.01
        myAT <- c(1,round(n.Total * pct,0))
        myLab <- data.plot[,ContData.env$myName.Date][myAT]
        #
        myPlot.Y <- na.omit(as.numeric(data.plot[,i])) 
        #20170518, v2.0.1.9008, coming in as text add na.omit(as.numeric(x))
        myPlot.Ylab <- myParameters.Lab[i.num]
        plot(myPlot.Y,type="l",main=mySiteID,xlab=ContData.env$myLab.Date
             ,ylab=myPlot.Ylab,col="gray", xaxt="n")
        axis(1,at=myAT,labels=myLab,tick=TRUE)
        # Add discrete (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) # coerce "NA" to NA
          data.plot.points <- na.omit(data.plot[,c(ContData.env$myName.DateTime,myDiscrete)]) 
          # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="black",pch=19) 
        }##IF.Discrete.END
        cat("\n\n")
        cat("Discrete measurements, if any, show up as points on the plot.")
        cat("\n\n")
      } else if(plot_format=="ggplot"){
        # plot, ggplot ####
        data.plot[, ContData.env$myName.DateTime] <- as.POSIXct(data.plot[, ContData.env$myName.DateTime])
        # ggplot, main
        scale_lab   <- c("Continuous", "Discrete")
        scale_col   <- c("dark gray", "black")
        scale_shape <- c(21, 24)
        scale_fill  <- scale_col
        p_i <- ggplot2::ggplot(data=data.plot, ggplot2::aes_string(x=ContData.env$myName.DateTime, y=i)) +
                ggplot2::geom_point(ggplot2::aes(color="continuous"
                                                 , shape="continuous"
                                                 , fill="continuous"), na.rm=TRUE) + 
                ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") + 
                ggplot2::labs(title=mySiteID, x=ContData.env$myLab.Date, y=myParameters.Lab[i.num]) +
                ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
                               , plot.subtitle=ggplot2::element_text(hjust=0.5))
        # ggplot, discrete points
        # Add discrete (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete,i,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
          p_i <- p_i + ggplot2::geom_point(data=data.plot
                                           , ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                                            , y=as.name(myDiscrete)
                                                            , color="discrete"
                                                            , shape="discrete"
                                                            , fill="discrete"), na.rm=TRUE) 
        } else {
         p_i <- p_i + ggplot2::geom_blank(ggplot2::aes(color="discrete"
                                                       , shape="discrete"
                                                       , fill="discrete"))
        }##IF.Discrete.END
        # ggplot, Legend
        p_i <- p_i + 
                ggplot2::scale_color_manual(name="Data Type", labels=scale_lab, values=scale_col) +
                ggplot2::scale_shape_manual(name="Data Type", labels=scale_lab, values=scale_shape) +
                ggplot2::scale_fill_manual(name="Data Type", labels=scale_lab, values=scale_fill) 
        # ggplot, show 
        print(p_i)
        cat("\n\n")
      }##IF~plot_format~END
     

      
      #
    }##FOR.i.END

```

# PLOTS, MULTIPARAMETER
Multiparameter plots if exist in the data.

```{r plots}
 # BOTH plots
    
    # 3.3. Plot
    data.plot <- data.import

    plot_format <- "ggplot" # "base" or "ggplot"

    # Plot
    if(plot_format=="base") {##IF~plot_format~START
      # plot, base ####
      # cheat on Date/Time axis
      n.Total <- length(data.plot[,ContData.env$myName.Date])
      pct <- c(20,40,60,80,100)*.01
      myAT <- c(1,round(n.Total * pct,0))
      myLab <- data.plot[,ContData.env$myName.Date][myAT]
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # Need to check for parameters before plot
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
      
      # Temp, Air vs. Water
      if (ContData.env$myName.AirTemp %in% myParameters &
          ContData.env$myName.WaterTemp %in% myParameters == TRUE) {
        cat("## PLOT, Temperature (Air vs. Water) \n\n" )
        #
        par.orig <- par(no.readonly=TRUE) # save original par settings
        layout(rbind(1,2),heights=c(7,1))
        #
        myPlot.Y <- na.omit(as.numeric(data.plot[,ContData.env$myName.AirTemp]))
        # 20170518, v2.0.1.9008
        myPlot.Y2 <- na.omit(as.numeric(data.plot[
                                               ,ContData.env$myName.WaterTemp]))
        # 20170518, v2.0.1.9008
        myPlot.Ylab <- ContData.env$myLab.Temp.BOTH
        plot(myPlot.Y
             ,type="l"
             ,main=mySiteID
             ,xlab=ContData.env$myLab.Date
             ,ylab=myPlot.Ylab
             ,col="green"
             , xaxt="n")
        # Revised myAT for lots of NA (20170518)
        data.length <- length(myPlot.Y)
        myAT <- c(1,round(data.length * pct,0))
        #
        axis(1,at=myAT,labels=myLab,tick=TRUE)
        lines(myPlot.Y2,type="l",col="blue")
        #legend(x="bottomright",lty=1,col=c("green","blue")
        # ,legend=c("air","water"))
        # Add discrete, AirTemp (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete
                            ,ContData.env$myName.AirTemp
                            ,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){##IF.Discrete.START
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) 
          # coerce "NA" to NA
          data.plot.points <-
            na.omit(data.plot[,c(ContData.env$myName.DateTime,myDiscrete)]) 
          # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="green",pch=19) 
        }##IF.Discrete.END
        # Add discrete, Water.Temp (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete
                            ,ContData.env$myName.WaterTemp
                            ,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) 
          # coerce "NA" to NA
          data.plot.points <-
            na.omit(data.plot[,c(ContData.env$myName.DateTime,myDiscrete)]) 
          # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="blue",pch=19) 
        }##IF.Discrete.END
        #
        # LEGEND
        par(mar=c(0,0,0,0))
        plot.new()
        legend(x="center"
               ,lty=1
               ,col=c("green","blue")
               ,legend=c("air","water")
               ,bty="n")
        #
        par(par.orig) # return to original par settings
        #
        # Future mod, add points to legend
        cat("\n\n")
        cat("Discrete measurements, if any, show up as points on the plot.")
        cat("\n\n")
  
        #
      }##IF.Temp.END
      #
      # Water, Temp vs Sensor Depth
      if (ContData.env$myName.WaterTemp %in% myParameters 
          & ContData.env$myName.SensorDepth %in% myParameters == TRUE) {
        cat("## PLOT, Sensor Depth vs. Water Temperature \n\n")
        #
        par.orig <- par(no.readonly=TRUE) # save original par settings
        layout(rbind(1,2),heights=c(7,1))
        par(oma=c(0,0,0,2))
        #
        myPlot.Y <- na.omit(as.numeric(data.plot[
          ,ContData.env$myName.WaterTemp])) 
        # 20170518, v2.0.1.9008
        myPlot.Ylab <- ContData.env$myLab.WaterTemp
        myPlot.Y2 <- na.omit(as.numeric(data.plot[
          ,ContData.env$myName.SensorDepth]))
        # 20170518, v2.0.1.9008
        myPlot.Y2lab <- ContData.env$myLab.SensorDepth
        #
        plot(myPlot.Y
             ,type="l"
             ,main=mySiteID
             ,xlab=ContData.env$myLab.Date
             ,ylab=myPlot.Ylab
             ,col="blue"
             , xaxt="n")
        # Revised myAT for lots of NA (20170518)
        data.length <- length(myPlot.Y)
        myAT <- c(1,round(data.length * pct,0))
        #
        axis(1,at=myAT,labels=myLab,tick=TRUE)
        # Add discrete, Water.Temp (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete
                            ,ContData.env$myName.WaterTemp
                            ,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) 
          # coerce "NA" to NA
          data.plot.points <- na.omit(data.plot[
            ,c(ContData.env$myName.DateTime,myDiscrete)]) # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="blue",pch=19) 
        }##IF.Discrete.END
        #
        # Add 2nd y axis (2nd color is black)
        par(new=TRUE)
        plot(myPlot.Y2,type="l",col="black",axes=FALSE,ann=FALSE)
        axis(4)
        mtext(myPlot.Y2lab,side=4,line=2.5)
        # Add discrete, SensorDepth (only if present)
        myDiscrete <- paste(ContData.env$myPrefix.Discrete
                            ,ContData.env$myName.SensorDepth,sep=".")
        if (myDiscrete %in% myParameters.ALL == TRUE){
          data.plot[,myDiscrete] <- as.numeric(data.plot[,myDiscrete]) 
          # coerce "NA" to NA
          data.plot.points <- na.omit(data.plot[
            ,c(ContData.env$myName.DateTime,myDiscrete)]) # remove NA
          myPoints.X <- as.numeric(rownames(data.plot.points))
          myPoints.Y <- data.plot.points[,myDiscrete]
          points(myPoints.Y~myPoints.X,col="black",pch=19) 
        }##IF.Discrete.END
        #
        # LEGEND
        par(mar=c(0,0,0,0))
        plot.new()
        legend(x="center"
               ,lty=1
               ,col=c("blue","black")
               ,legend=c("temperature"
                         ,"sensor depth")
               ,bty="n")
      #
        # Future mod, add points to legend
        #
        par(par.orig) # return to original par settings
        cat("\n\n")
        cat("Discrete measurements, if any, show up as points on the plot.")
        cat("\n\n")
      }##IF.Temp_Level.END  
    } else if(plot_format=="ggplot"){
      # plot, ggplot ####
      # date to POSIX
      data.plot[, ContData.env$myName.DateTime] <- 
        as.POSIXct(data.plot[, ContData.env$myName.DateTime])
      #
      # Temp, Air vs. Water
      if (ContData.env$myName.AirTemp %in% myParameters & 
          ContData.env$myName.WaterTemp %in% myParameters ) {
        cat("## PLOT, Temperature (Air vs. Water) \n\n" )
        #
        # ggplot, main
        scale_lab   <- c("Air", "Water")
        scale_col   <- c("green", "blue")
        scale_fill  <- scale_col   
        scale_shape <- c(21, 21)
    
        p2_t_aw <- ggplot2::ggplot(data=data.plot, ggplot2::aes(color="a"
                                                                , fill="b"
                                                                , shape="c")) +
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name(ContData.env$myName.AirTemp)
                                            , color="air")
                             , na.rm=TRUE) + 
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name(ContData.env$myName.WaterTemp)
                                             , color="water")
                             , na.rm=TRUE) + 
          ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") + 
          ggplot2::labs(title=mySiteID
                        , x=ContData.env$myLab.Date
                        , y=ContData.env$myLab.Temp.BOTH) +
          ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
                         , plot.subtitle=ggplot2::element_text(hjust=0.5))
        # ggplot, discrete points
        ## skip
        
        # ggplot, Legend
        p2_t_aw <- p2_t_aw + 
                ggplot2::scale_color_manual(name="Data Type"
                                            , labels=scale_lab
                                            , values=scale_col) 
                
        # ggplot, show 
        print(p2_t_aw)
        cat("\n\n")
        #
      }##IF.Temp.END
      #
      # Water, Temp vs Sensor Depth
      if (ContData.env$myName.WaterTemp %in% myParameters &
          ContData.env$myName.SensorDepth %in% myParameters) {
        cat("## PLOT, Sensor Depth vs. Water Temperature \n\n")
        #
        # ggplot, main
        scale_lab   <- c("Water Temp", "Sensor Depth")
        scale_col   <- c("blue", "black")
        scale_fill  <- scale_col   
        scale_shape <- c(21, 21)
        
        # ggplot intentionaly not designed for dual y plotting
        min_diff <- 
          min(data.plot[, ContData.env$myName.WaterTemp], na.rm=TRUE) -
          min(data.plot[, ContData.env$myName.SensorDepth], na.rm=TRUE)
        rd_y1 <- diff(range(data.plot[, ContData.env$myName.WaterTemp]
                            , na.rm = TRUE))
        rd_y2 <- diff(range(data.plot[, ContData.env$myName.SensorDepth]
                            , na.rm = TRUE))
        min_y1 <- min(data.plot[, ContData.env$myName.WaterTemp]) 
        max_y1 <- max(data.plot[, ContData.env$myName.WaterTemp])
        avg_y1 <- mean(data.plot[, ContData.env$myName.WaterTemp])
        data.plot[, "depth4plot"] <- 
          (data.plot[, ContData.env$myName.SensorDepth] * rd_y1/rd_y2) + 
             min_diff
    
        p3_td <- ggplot2::ggplot(data=data.plot) +
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name(ContData.env$myName.WaterTemp)
                                            , color="water")
                             , na.rm=TRUE) + 
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name("depth4plot")
                                            , color="depth"), na.rm = TRUE) + 
          ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") + 
          ggplot2::labs(title=mySiteID
                        , x=ContData.env$myLab.Date
                        , y=ContData.env$myLab.WaterTemp) +
          ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
                         , plot.subtitle=ggplot2::element_text(hjust=0.5))
        # ggplot, add 2nd Y
        p3_td <- p3_td +  ggplot2::scale_y_continuous(sec.axis = ggplot2::sec_axis(
                  trans=~./(rd_y1/rd_y2)-(min_diff/(rd_y1/rd_y2))
                  , name=ContData.env$myLab.SensorDepth))
        
        # ggplot, discrete points
        ## skip
        
        # ggplot, Legend
        ## need to reverse legend items to be correct.
        p3_td <- p3_td + 
          ggplot2::scale_color_manual(name="Data Type"
                                      , labels=rev(scale_lab)
                                      , values=rev(scale_col))
                
        # ggplot, show 
        print(p3_td)
        cat("\n\n")
        #
      }##IF.Temp_SensorDepth.END 
      
       # Water, Temp vs Sensor Depth
      if (ContData.env$myName.WaterTemp %in% myParameters &
          ContData.env$myName.WaterLevel %in% myParameters) {
        cat("## PLOT, Water Level vs. Water Temperature \n\n")
        #
        # ggplot, main
        scale_lab   <- c("Water Temp", "Water Level")
        scale_col   <- c("blue", "black")
        scale_fill  <- scale_col   
        scale_shape <- c(21, 21)
        
        # ggplot intentionaly not designed for dual y plotting
        min_diff <- 
          min(data.plot[, ContData.env$myName.WaterTemp], na.rm=TRUE) -
          min(data.plot[, ContData.env$myName.WaterLevel], na.rm=TRUE)
        rd_y1 <- diff(range(data.plot[, ContData.env$myName.WaterTemp]
                            , na.rm = TRUE))
        rd_y2 <- diff(range(data.plot[, ContData.env$myName.WaterLevel]
                            , na.rm = TRUE))
        min_y1 <- min(data.plot[, ContData.env$myName.WaterTemp]) 
        max_y1 <- max(data.plot[, ContData.env$myName.WaterTemp])
        avg_y1 <- mean(data.plot[, ContData.env$myName.WaterTemp])
        data.plot[, "depth4plot"] <- 
          (data.plot[, ContData.env$myName.WaterLevel] * rd_y1/rd_y2) + 
             min_diff
    
        p4_td <- ggplot2::ggplot(data=data.plot) +
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name(ContData.env$myName.WaterTemp)
                                            , color="water")
                             , na.rm=TRUE) + 
          ggplot2::geom_path(ggplot2::aes_q(x=as.name(ContData.env$myName.DateTime)
                                            ,y=as.name("depth4plot")
                                            , color="depth"), na.rm = TRUE) + 
          ggplot2::scale_x_datetime(date_labels = "%Y-%m-%d") + 
          ggplot2::labs(title=mySiteID
                        , x=ContData.env$myLab.Date
                        , y=ContData.env$myLab.WaterTemp) +
          ggplot2::theme(plot.title=ggplot2::element_text(hjust=0.5)
                         , plot.subtitle=ggplot2::element_text(hjust=0.5))
        # ggplot, add 2nd Y
        p4_td <- p4_td +  ggplot2::scale_y_continuous(sec.axis = ggplot2::sec_axis(
                  trans=~./(rd_y1/rd_y2)-(min_diff/(rd_y1/rd_y2))
                  , name=ContData.env$myLab.WaterLevel))
        
        # ggplot, discrete points
        ## skip
        
        # ggplot, Legend
        ## need to reverse legend items to be correct.
        p4_td <- p4_td + 
          ggplot2::scale_color_manual(name="Data Type"
                                      , labels=rev(scale_lab)
                                      , values=rev(scale_col))
                
        # ggplot, show 
        print(p4_td)
        cat("\n\n")
        #
      }##IF.Temp_Level.END 
      
    }##IF~plot_format~START
    
    
   # '''
```

